///
/// @Generated by Mockolo
///



import Foundation
import Vapor
@testable import Domain


public final class ITrainerRepositoryMock: ITrainerRepository, @unchecked Sendable {
    public init() { }


    private let createState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Trainer) async throws -> ()>())
    public var createCallCount: Int {
        return createState.withLock(\.callCount)
    }
    public var createHandler: (@Sendable (Trainer) async throws -> ())? {
        get { createState.withLock(\.handler) }
        set { createState.withLock { $0.handler = newValue } }
    }
    public func create(_ trainer: Trainer) async throws {
        let createHandler = createState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let createHandler = createHandler {
            try await createHandler(trainer)
        }
        
    }

    private let updateState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Trainer) async throws -> ()>())
    public var updateCallCount: Int {
        return updateState.withLock(\.callCount)
    }
    public var updateHandler: (@Sendable (Trainer) async throws -> ())? {
        get { updateState.withLock(\.handler) }
        set { updateState.withLock { $0.handler = newValue } }
    }
    public func update(_ trainer: Trainer) async throws {
        let updateHandler = updateState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let updateHandler = updateHandler {
            try await updateHandler(trainer)
        }
        
    }

    private let deleteState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> ()>())
    public var deleteCallCount: Int {
        return deleteState.withLock(\.callCount)
    }
    public var deleteHandler: (@Sendable (UUID) async throws -> ())? {
        get { deleteState.withLock(\.handler) }
        set { deleteState.withLock { $0.handler = newValue } }
    }
    public func delete(id: UUID) async throws {
        let deleteHandler = deleteState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let deleteHandler = deleteHandler {
            try await deleteHandler(id)
        }
        
    }

    private let findState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> Trainer?>())
    public var findCallCount: Int {
        return findState.withLock(\.callCount)
    }
    public var findHandler: (@Sendable (UUID) async throws -> Trainer?)? {
        get { findState.withLock(\.handler) }
        set { findState.withLock { $0.handler = newValue } }
    }
    public func find(id: UUID) async throws -> Trainer? {
        let findHandler = findState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findHandler = findHandler {
            return try await findHandler(id)
        }
        return nil
    }

    private let findUserIdState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> Trainer?>())
    public var findUserIdCallCount: Int {
        return findUserIdState.withLock(\.callCount)
    }
    public var findUserIdHandler: (@Sendable (UUID) async throws -> Trainer?)? {
        get { findUserIdState.withLock(\.handler) }
        set { findUserIdState.withLock { $0.handler = newValue } }
    }
    public func find(userId: UUID) async throws -> Trainer? {
        let findUserIdHandler = findUserIdState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findUserIdHandler = findUserIdHandler {
            return try await findUserIdHandler(userId)
        }
        return nil
    }

    private let findAllState = MockoloMutex(MockoloHandlerState<Never, @Sendable () async throws -> [Trainer]>())
    public var findAllCallCount: Int {
        return findAllState.withLock(\.callCount)
    }
    public var findAllHandler: (@Sendable () async throws -> [Trainer])? {
        get { findAllState.withLock(\.handler) }
        set { findAllState.withLock { $0.handler = newValue } }
    }
    public func findAll() async throws -> [Trainer] {
        let findAllHandler = findAllState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findAllHandler = findAllHandler {
            return try await findAllHandler()
        }
        return [Trainer]()
    }
}

fileprivate func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
    print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

fileprivate func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {
}

/// Will be replaced to `Synchronization.Mutex` in future.
fileprivate final class MockoloMutex<Value>: @unchecked Sendable {
    private let lock = NSLock()
    private var value: Value
    init(_ initialValue: Value) {
        self.value = initialValue
    }
#if compiler(>=6.0)
    borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#else
    func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#endif
}

fileprivate struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
    var value: Value
    init(_ value: Value) {
        self.value = value
    }
}

fileprivate struct MockoloHandlerState<Arg, Handler> {
    var argValues: [MockoloUnsafeTransfer<Arg>] = []
    var handler: Handler? = nil
    var callCount: Int = 0
}

