///
/// @Generated by Mockolo
///



import Foundation
@testable import Domain


public final class IHasherServiceMock: IHasherService, @unchecked Sendable {
    public init() { }


    private let hashState = MockoloMutex(MockoloHandlerState<Never, @Sendable (String) throws -> String>())
    public var hashCallCount: Int {
        return hashState.withLock(\.callCount)
    }
    public var hashHandler: (@Sendable (String) throws -> String)? {
        get { hashState.withLock(\.handler) }
        set { hashState.withLock { $0.handler = newValue } }
    }
    public func hash(_ value: String) throws -> String {
        let hashHandler = hashState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let hashHandler = hashHandler {
            return try hashHandler(value)
        }
        return ""
    }

    private let verifyState = MockoloMutex(MockoloHandlerState<Never, @Sendable (String, String) throws -> Bool>())
    public var verifyCallCount: Int {
        return verifyState.withLock(\.callCount)
    }
    public var verifyHandler: (@Sendable (String, String) throws -> Bool)? {
        get { verifyState.withLock(\.handler) }
        set { verifyState.withLock { $0.handler = newValue } }
    }
    public func verify(_ value: String, created hash: String) throws -> Bool {
        let verifyHandler = verifyState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let verifyHandler = verifyHandler {
            return try verifyHandler(value, hash)
        }
        return false
    }
}

fileprivate func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
    print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

fileprivate func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {
}

/// Will be replaced to `Synchronization.Mutex` in future.
fileprivate final class MockoloMutex<Value>: @unchecked Sendable {
    private let lock = NSLock()
    private var value: Value
    init(_ initialValue: Value) {
        self.value = initialValue
    }
#if compiler(>=6.0)
    borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#else
    func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#endif
}

fileprivate struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
    var value: Value
    init(_ value: Value) {
        self.value = value
    }
}

fileprivate struct MockoloHandlerState<Arg, Handler> {
    var argValues: [MockoloUnsafeTransfer<Arg>] = []
    var handler: Handler? = nil
    var callCount: Int = 0
}

