///
/// @Generated by Mockolo
///



import Foundation
import Vapor
@testable import Domain


public final class ITrainingRepositoryMock: ITrainingRepository, @unchecked Sendable {
    public init() { }


    private let createState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Training) async throws -> ()>())
    public var createCallCount: Int {
        return createState.withLock(\.callCount)
    }
    public var createHandler: (@Sendable (Training) async throws -> ())? {
        get { createState.withLock(\.handler) }
        set { createState.withLock { $0.handler = newValue } }
    }
    public func create(_ training: Training) async throws {
        let createHandler = createState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let createHandler = createHandler {
            try await createHandler(training)
        }
        
    }

    private let updateState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Training) async throws -> ()>())
    public var updateCallCount: Int {
        return updateState.withLock(\.callCount)
    }
    public var updateHandler: (@Sendable (Training) async throws -> ())? {
        get { updateState.withLock(\.handler) }
        set { updateState.withLock { $0.handler = newValue } }
    }
    public func update(_ training: Training) async throws {
        let updateHandler = updateState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let updateHandler = updateHandler {
            try await updateHandler(training)
        }
        
    }

    private let deleteState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> ()>())
    public var deleteCallCount: Int {
        return deleteState.withLock(\.callCount)
    }
    public var deleteHandler: (@Sendable (UUID) async throws -> ())? {
        get { deleteState.withLock(\.handler) }
        set { deleteState.withLock { $0.handler = newValue } }
    }
    public func delete(id: UUID) async throws {
        let deleteHandler = deleteState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let deleteHandler = deleteHandler {
            try await deleteHandler(id)
        }
        
    }

    private let findState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> Training?>())
    public var findCallCount: Int {
        return findState.withLock(\.callCount)
    }
    public var findHandler: (@Sendable (UUID) async throws -> Training?)? {
        get { findState.withLock(\.handler) }
        set { findState.withLock { $0.handler = newValue } }
    }
    public func find(id: UUID) async throws -> Training? {
        let findHandler = findState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findHandler = findHandler {
            return try await findHandler(id)
        }
        return nil
    }

    private let findTrainerIdState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> [Training]>())
    public var findTrainerIdCallCount: Int {
        return findTrainerIdState.withLock(\.callCount)
    }
    public var findTrainerIdHandler: (@Sendable (UUID) async throws -> [Training])? {
        get { findTrainerIdState.withLock(\.handler) }
        set { findTrainerIdState.withLock { $0.handler = newValue } }
    }
    public func find(trainerId: UUID) async throws -> [Training] {
        let findTrainerIdHandler = findTrainerIdState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findTrainerIdHandler = findTrainerIdHandler {
            return try await findTrainerIdHandler(trainerId)
        }
        return [Training]()
    }

    private let findTrainingRoomIdState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> [Training]>())
    public var findTrainingRoomIdCallCount: Int {
        return findTrainingRoomIdState.withLock(\.callCount)
    }
    public var findTrainingRoomIdHandler: (@Sendable (UUID) async throws -> [Training])? {
        get { findTrainingRoomIdState.withLock(\.handler) }
        set { findTrainingRoomIdState.withLock { $0.handler = newValue } }
    }
    public func find(trainingRoomId: UUID) async throws -> [Training] {
        let findTrainingRoomIdHandler = findTrainingRoomIdState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findTrainingRoomIdHandler = findTrainingRoomIdHandler {
            return try await findTrainingRoomIdHandler(trainingRoomId)
        }
        return [Training]()
    }

    private let findDateState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Date) async throws -> [Training]>())
    public var findDateCallCount: Int {
        return findDateState.withLock(\.callCount)
    }
    public var findDateHandler: (@Sendable (Date) async throws -> [Training])? {
        get { findDateState.withLock(\.handler) }
        set { findDateState.withLock { $0.handler = newValue } }
    }
    public func find(date: Date) async throws -> [Training] {
        let findDateHandler = findDateState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findDateHandler = findDateHandler {
            return try await findDateHandler(date)
        }
        return [Training]()
    }

    private let findAllState = MockoloMutex(MockoloHandlerState<Never, @Sendable () async throws -> [Training]>())
    public var findAllCallCount: Int {
        return findAllState.withLock(\.callCount)
    }
    public var findAllHandler: (@Sendable () async throws -> [Training])? {
        get { findAllState.withLock(\.handler) }
        set { findAllState.withLock { $0.handler = newValue } }
    }
    public func findAll() async throws -> [Training] {
        let findAllHandler = findAllState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findAllHandler = findAllHandler {
            return try await findAllHandler()
        }
        return [Training]()
    }
}

fileprivate func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
    print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

fileprivate func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {
}

/// Will be replaced to `Synchronization.Mutex` in future.
fileprivate final class MockoloMutex<Value>: @unchecked Sendable {
    private let lock = NSLock()
    private var value: Value
    init(_ initialValue: Value) {
        self.value = initialValue
    }
#if compiler(>=6.0)
    borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#else
    func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#endif
}

fileprivate struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
    var value: Value
    init(_ value: Value) {
        self.value = value
    }
}

fileprivate struct MockoloHandlerState<Arg, Handler> {
    var argValues: [MockoloUnsafeTransfer<Arg>] = []
    var handler: Handler? = nil
    var callCount: Int = 0
}

