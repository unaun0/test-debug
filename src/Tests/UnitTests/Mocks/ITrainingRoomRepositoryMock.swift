///
/// @Generated by Mockolo
///



import Foundation
import Vapor

@testable import Domain


public final class ITrainingRoomRepositoryMock: ITrainingRoomRepository, @unchecked Sendable {
    public init() { }


    private let createState = MockoloMutex(MockoloHandlerState<Never, @Sendable (TrainingRoom) async throws -> ()>())
    public var createCallCount: Int {
        return createState.withLock(\.callCount)
    }
    public var createHandler: (@Sendable (TrainingRoom) async throws -> ())? {
        get { createState.withLock(\.handler) }
        set { createState.withLock { $0.handler = newValue } }
    }
    public func create(_ room: TrainingRoom) async throws {
        let createHandler = createState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let createHandler = createHandler {
            try await createHandler(room)
        }
        
    }

    private let updateState = MockoloMutex(MockoloHandlerState<Never, @Sendable (TrainingRoom) async throws -> ()>())
    public var updateCallCount: Int {
        return updateState.withLock(\.callCount)
    }
    public var updateHandler: (@Sendable (TrainingRoom) async throws -> ())? {
        get { updateState.withLock(\.handler) }
        set { updateState.withLock { $0.handler = newValue } }
    }
    public func update(_ room: TrainingRoom) async throws {
        let updateHandler = updateState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let updateHandler = updateHandler {
            try await updateHandler(room)
        }
        
    }

    private let deleteState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> ()>())
    public var deleteCallCount: Int {
        return deleteState.withLock(\.callCount)
    }
    public var deleteHandler: (@Sendable (UUID) async throws -> ())? {
        get { deleteState.withLock(\.handler) }
        set { deleteState.withLock { $0.handler = newValue } }
    }
    public func delete(id: UUID) async throws {
        let deleteHandler = deleteState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let deleteHandler = deleteHandler {
            try await deleteHandler(id)
        }
        
    }

    private let findState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> TrainingRoom?>())
    public var findCallCount: Int {
        return findState.withLock(\.callCount)
    }
    public var findHandler: (@Sendable (UUID) async throws -> TrainingRoom?)? {
        get { findState.withLock(\.handler) }
        set { findState.withLock { $0.handler = newValue } }
    }
    public func find(id: UUID) async throws -> TrainingRoom? {
        let findHandler = findState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findHandler = findHandler {
            return try await findHandler(id)
        }
        return nil
    }

    private let findNameState = MockoloMutex(MockoloHandlerState<Never, @Sendable (String) async throws -> TrainingRoom?>())
    public var findNameCallCount: Int {
        return findNameState.withLock(\.callCount)
    }
    public var findNameHandler: (@Sendable (String) async throws -> TrainingRoom?)? {
        get { findNameState.withLock(\.handler) }
        set { findNameState.withLock { $0.handler = newValue } }
    }
    public func find(name: String) async throws -> TrainingRoom? {
        let findNameHandler = findNameState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findNameHandler = findNameHandler {
            return try await findNameHandler(name)
        }
        return nil
    }

    private let findCapacityState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Int) async throws -> [TrainingRoom]>())
    public var findCapacityCallCount: Int {
        return findCapacityState.withLock(\.callCount)
    }
    public var findCapacityHandler: (@Sendable (Int) async throws -> [TrainingRoom])? {
        get { findCapacityState.withLock(\.handler) }
        set { findCapacityState.withLock { $0.handler = newValue } }
    }
    public func find(capacity: Int) async throws -> [TrainingRoom] {
        let findCapacityHandler = findCapacityState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findCapacityHandler = findCapacityHandler {
            return try await findCapacityHandler(capacity)
        }
        return [TrainingRoom]()
    }

    private let findAllState = MockoloMutex(MockoloHandlerState<Never, @Sendable () async throws -> [TrainingRoom]>())
    public var findAllCallCount: Int {
        return findAllState.withLock(\.callCount)
    }
    public var findAllHandler: (@Sendable () async throws -> [TrainingRoom])? {
        get { findAllState.withLock(\.handler) }
        set { findAllState.withLock { $0.handler = newValue } }
    }
    public func findAll() async throws -> [TrainingRoom] {
        let findAllHandler = findAllState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findAllHandler = findAllHandler {
            return try await findAllHandler()
        }
        return [TrainingRoom]()
    }
}

fileprivate func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
    print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

fileprivate func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {
}

/// Will be replaced to `Synchronization.Mutex` in future.
fileprivate final class MockoloMutex<Value>: @unchecked Sendable {
    private let lock = NSLock()
    private var value: Value
    init(_ initialValue: Value) {
        self.value = initialValue
    }
#if compiler(>=6.0)
    borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#else
    func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#endif
}

fileprivate struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
    var value: Value
    init(_ value: Value) {
        self.value = value
    }
}

fileprivate struct MockoloHandlerState<Arg, Handler> {
    var argValues: [MockoloUnsafeTransfer<Arg>] = []
    var handler: Handler? = nil
    var callCount: Int = 0
}

