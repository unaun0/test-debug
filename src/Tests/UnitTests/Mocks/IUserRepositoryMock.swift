///
/// @Generated by Mockolo
///

import Foundation
import Vapor
@testable import Domain


public final class IUserRepositoryMock: IUserRepository, @unchecked Sendable {
    public init() { }

    private let createState = MockoloMutex(MockoloHandlerState<Never, @Sendable (User) async throws -> ()>())
    public var createCallCount: Int {
        return createState.withLock(\.callCount)
    }
    public var createHandler: (@Sendable (User) async throws -> ())? {
        get { createState.withLock(\.handler) }
        set { createState.withLock { $0.handler = newValue } }
    }
    public func create(_ user: User) async throws {
        let createHandler = createState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let createHandler = createHandler {
            try await createHandler(user)
        }
        
    }

    private let updateState = MockoloMutex(MockoloHandlerState<Never, @Sendable (User) async throws -> ()>())
    public var updateCallCount: Int {
        return updateState.withLock(\.callCount)
    }
    public var updateHandler: (@Sendable (User) async throws -> ())? {
        get { updateState.withLock(\.handler) }
        set { updateState.withLock { $0.handler = newValue } }
    }
    public func update(_ user: User) async throws {
        let updateHandler = updateState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let updateHandler = updateHandler {
            try await updateHandler(user)
        }
        
    }

    private let deleteState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> ()>())
    public var deleteCallCount: Int {
        return deleteState.withLock(\.callCount)
    }
    public var deleteHandler: (@Sendable (UUID) async throws -> ())? {
        get { deleteState.withLock(\.handler) }
        set { deleteState.withLock { $0.handler = newValue } }
    }
    public func delete(id: UUID) async throws {
        let deleteHandler = deleteState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let deleteHandler = deleteHandler {
            try await deleteHandler(id)
        }
        
    }

    private let findState = MockoloMutex(MockoloHandlerState<Never, @Sendable (String) async throws -> User?>())
    public var findCallCount: Int {
        return findState.withLock(\.callCount)
    }
    public var findHandler: (@Sendable (String) async throws -> User?)? {
        get { findState.withLock(\.handler) }
        set { findState.withLock { $0.handler = newValue } }
    }
    public func find(email: String) async throws -> User? {
        let findHandler = findState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findHandler = findHandler {
            return try await findHandler(email)
        }
        return nil
    }

    private let findIdState = MockoloMutex(MockoloHandlerState<Never, @Sendable (UUID) async throws -> User?>())
    public var findIdCallCount: Int {
        return findIdState.withLock(\.callCount)
    }
    public var findIdHandler: (@Sendable (UUID) async throws -> User?)? {
        get { findIdState.withLock(\.handler) }
        set { findIdState.withLock { $0.handler = newValue } }
    }
    public func find(id: UUID) async throws -> User? {
        let findIdHandler = findIdState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findIdHandler = findIdHandler {
            return try await findIdHandler(id)
        }
        return nil
    }

    private let findPhoneNumberState = MockoloMutex(MockoloHandlerState<Never, @Sendable (String) async throws -> User?>())
    public var findPhoneNumberCallCount: Int {
        return findPhoneNumberState.withLock(\.callCount)
    }
    public var findPhoneNumberHandler: (@Sendable (String) async throws -> User?)? {
        get { findPhoneNumberState.withLock(\.handler) }
        set { findPhoneNumberState.withLock { $0.handler = newValue } }
    }
    public func find(phoneNumber: String) async throws -> User? {
        let findPhoneNumberHandler = findPhoneNumberState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findPhoneNumberHandler = findPhoneNumberHandler {
            return try await findPhoneNumberHandler(phoneNumber)
        }
        return nil
    }

    private let findAllState = MockoloMutex(MockoloHandlerState<Never, @Sendable () async throws -> [User]>())
    public var findAllCallCount: Int {
        return findAllState.withLock(\.callCount)
    }
    public var findAllHandler: (@Sendable () async throws -> [User])? {
        get { findAllState.withLock(\.handler) }
        set { findAllState.withLock { $0.handler = newValue } }
    }
    public func findAll() async throws -> [User] {
        let findAllHandler = findAllState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findAllHandler = findAllHandler {
            return try await findAllHandler()
        }
        return [User]()
    }

    private let findRoleState = MockoloMutex(MockoloHandlerState<Never, @Sendable (String) async throws -> [User]>())
    public var findRoleCallCount: Int {
        return findRoleState.withLock(\.callCount)
    }
    public var findRoleHandler: (@Sendable (String) async throws -> [User])? {
        get { findRoleState.withLock(\.handler) }
        set { findRoleState.withLock { $0.handler = newValue } }
    }
    public func find(role: String) async throws -> [User] {
        let findRoleHandler = findRoleState.withLock { state in
            state.callCount += 1
            return state.handler
        }
        if let findRoleHandler = findRoleHandler {
            return try await findRoleHandler(role)
        }
        return [User]()
    }
}

fileprivate func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
    print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

fileprivate func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {
}

/// Will be replaced to `Synchronization.Mutex` in future.
fileprivate final class MockoloMutex<Value>: @unchecked Sendable {
    private let lock = NSLock()
    private var value: Value
    init(_ initialValue: Value) {
        self.value = initialValue
    }
#if compiler(>=6.0)
    borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#else
    func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
        lock.lock()
        defer { lock.unlock() }
        return try body(&value)
    }
#endif
}

fileprivate struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
    var value: Value
    init(_ value: Value) {
        self.value = value
    }
}

fileprivate struct MockoloHandlerState<Arg, Handler> {
    var argValues: [MockoloUnsafeTransfer<Arg>] = []
    var handler: Handler? = nil
    var callCount: Int = 0
}

